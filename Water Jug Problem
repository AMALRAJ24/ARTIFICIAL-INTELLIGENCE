from collections import deque

def solve_water_jug(jug1_capacity, jug2_capacity, target):
    """
    Solve the water jug problem using BFS
    jug1_capacity: capacity of first jug
    jug2_capacity: capacity of second jug
    target: target amount of water to measure
    """
    
    def get_next_states(state):
        jug1, jug2 = state
        next_states = []
        
        # Fill jug 1
        next_states.append((jug1_capacity, jug2, "Fill Jug 1"))
        
        # Fill jug 2
        next_states.append((jug1, jug2_capacity, "Fill Jug 2"))
        
        # Empty jug 1
        next_states.append((0, jug2, "Empty Jug 1"))
        
        # Empty jug 2
        next_states.append((jug1, 0, "Empty Jug 2"))
        
        # Pour from jug 1 to jug 2
        pour_amount = min(jug1, jug2_capacity - jug2)
        next_states.append((jug1 - pour_amount, jug2 + pour_amount, 
                           f"Pour Jug 1 -> Jug 2 ({pour_amount}L)"))
        
        # Pour from jug 2 to jug 1
        pour_amount = min(jug2, jug1_capacity - jug1)
        next_states.append((jug1 + pour_amount, jug2 - pour_amount, 
                           f"Pour Jug 2 -> Jug 1 ({pour_amount}L)"))
        
        return next_states
    
    # BFS
    queue = deque([((0, 0), [])])
    visited = set()
    visited.add((0, 0))
    
    while queue:
        (current_state, path) = queue.popleft()
        jug1, jug2 = current_state
        
        # Check if target reached
        if jug1 == target or jug2 == target:
            return path, current_state
        
        # Explore next states
        for next_jug1, next_jug2, action in get_next_states(current_state):
            next_state = (next_jug1, next_jug2)
            
            if next_state not in visited:
                visited.add(next_state)
                queue.append((next_state, path + [(action, next_state)]))
    
    return None, None

def print_solution(path, final_state, jug1_cap, jug2_cap, target):
    print(f"\nWater Jug Problem: Jug1={jug1_cap}L, Jug2={jug2_cap}L, Target={target}L")
    print("=" * 60)
    
    if path is None:
        print("No solution exists!")
        return
    
    print(f"Solution found in {len(path)} steps:\n")
    print(f"Step 0: (0, 0) - Initial state")
    
    for i, (action, state) in enumerate(path, 1):
        jug1, jug2 = state
        print(f"Step {i}: ({jug1}, {jug2}) - {action}")
    
    print(f"\nTarget {target}L achieved in Jug {1 if final_state[0] == target else 2}!")

# Example 1: Classic 4L and 3L jug problem (measure 2L)
print("EXAMPLE 1: Classic Problem")
path, final = solve_water_jug(4, 3, 2)
print_solution(path, final, 4, 3, 2)

print("\n" + "=" * 60)

# Example 2: 5L and 3L jugs (measure 4L)
print("\nEXAMPLE 2: 5L and 3L jugs")
path, final = solve_water_jug(5, 3, 4)
print_solution(path, final, 5, 3, 4)

print("\n" + "=" * 60)

# Example 3: Custom problem
print("\nEXAMPLE 3: Custom Problem")
jug1_size = 7
jug2_size = 5
target_amount = 6
path, final = solve_water_jug(jug1_size, jug2_size, target_amount)
print_solution(path, final, jug1_size, jug2_size, target_amount)
